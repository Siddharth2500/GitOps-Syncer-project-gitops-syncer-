# -*- coding: utf-8 -*-
"""GitOps Syncer (project-gitops-syncer)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y1sEyvWd3UiDWmKNrdVAn4E3hqiXSSDK
"""

#!/usr/bin/env python3
"""
GitOps Syncer (Single-Section Full Version)

A safe, Jupyter/Colab-compatible GitOps helper that applies Kubernetes manifests
from a 'manifests/' folder. Defaults to dry-run mode unless --apply is given.

Usage examples (works everywhere):

Terminal:
    python gitops_syncer.py --manifests=manifests --apply

Jupyter / Colab:
    import gitops_syncer
    gitops_syncer.main(['--manifests', 'manifests', '--apply'])
or:
    !python gitops_syncer.py --manifests=manifests --apply

If you see: "No manifests found in 'manifests'. Nothing to do." â€” create a test manifest:
    mkdir -p manifests
    echo '
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: test-cm
    data:
      foo: bar
    ' > manifests/test-configmap.yaml
Then rerun the command.

"""

from __future__ import annotations
import argparse
import os
import subprocess
import sys
import hashlib
from concurrent.futures import ThreadPoolExecutor
from typing import List, Tuple

# ---------------- Utilities ----------------
def run_cmd(cmd: str, capture: bool = False) -> subprocess.CompletedProcess:
    print(f"$ {cmd}")
    return subprocess.run(cmd, shell=True, capture_output=capture, text=True)

def list_manifests(manifests_dir: str) -> List[str]:
    files = []
    if not os.path.isdir(manifests_dir):
        return files
    for root, _, filenames in os.walk(manifests_dir):
        for fn in filenames:
            if fn.endswith(('.yml', '.yaml')):
                files.append(os.path.join(root, fn))
    return sorted(files)

def compute_repo_hash(manifests: List[str]) -> str:
    h = hashlib.sha256()
    for p in manifests:
        rel = os.path.normpath(p).encode('utf-8')
        h.update(rel)
        try:
            with open(p, 'rb') as f:
                h.update(f.read())
        except Exception:
            continue
    return h.hexdigest()

def apply_manifest(path: str, kubecontext: str | None = None, dry_run: bool = True) -> subprocess.CompletedProcess:
    cmd = f"kubectl apply -f \"{path}\""
    if kubecontext:
        cmd += f" --context {kubecontext}"
    if dry_run:
        cmd += " --dry-run=client"
    return run_cmd(cmd, capture=True)

# ---------------- Core Logic ----------------
def sync(manifests_dir: str = "manifests", kubecontext: str | None = None, dry_run: bool = True, parallel: int = 4) -> int:
    manifests = list_manifests(manifests_dir)
    if not manifests:
        print(f"No manifests found in '{manifests_dir}'. Nothing to do.")
        return 0

    print(f"Found {len(manifests)} manifest(s). dry_run={dry_run}")
    repo_hash = compute_repo_hash(manifests)
    print("Manifests hash:", repo_hash)

    results: list[Tuple[str, int, str, str]] = []

    def worker(path: str):
        try:
            res = apply_manifest(path, kubecontext=kubecontext, dry_run=dry_run)
            rc = res.returncode
            out = res.stdout or ""
            err = res.stderr or ""
        except Exception as e:
            rc = 1
            out = ""
            err = str(e)
        results.append((path, rc, out, err))

    with ThreadPoolExecutor(max_workers=max(1, parallel)) as ex:
        for m in manifests:
            ex.submit(worker, m)

    failed = 0
    for path, rc, out, err in results:
        print(f"--- {path} (rc={rc}) ---")
        if out:
            print(out.strip())
        if err:
            print(err.strip(), file=sys.stderr)
        if rc != 0:
            failed += 1

    print(f"Sync complete: {len(manifests) - failed} succeeded, {failed} failed.")
    return 1 if failed else 0

# ---------------- CLI Parser ----------------
def build_arg_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(description="GitOps Syncer (safe for Jupyter/Colab)")
    p.add_argument('--manifests', default='manifests', help='directory containing Kubernetes manifests')
    p.add_argument('--context', default=None, help='kubecontext (optional)')
    p.add_argument('--apply', action='store_true', help='apply manifests (otherwise dry-run)')
    p.add_argument('--parallel', type=int, default=4, help='parallel threads for apply')
    return p

def in_interactive() -> bool:
    try:
        from IPython import get_ipython
        if get_ipython() is not None:
            return True
    except Exception:
        pass
    return bool(getattr(sys, 'ps1', False))

# ---------------- Main Entry ----------------
def main(argv: List[str] | None = None) -> int:
    parser = build_arg_parser()
    args, _unknown = parser.parse_known_args(argv)
    rc = sync(
        manifests_dir=args.manifests,
        kubecontext=args.context,
        dry_run=not args.apply,
        parallel=args.parallel
    )
    if in_interactive():
        print(f"[interactive] finished with return code: {rc}")
    return rc

if __name__ == "__main__":
    code = main()
    if not in_interactive():
        sys.exit(code)